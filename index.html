<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marin Speedrun - Leaderboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" defer></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'marin-blue': '#1a73e8',
                        'marin-dark': '#1e293b'
                    },
                    fontFamily: {
                        'display': ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50">
    <div class="min-h-screen">
        <header class="bg-marin-dark text-white shadow-lg">
            <div class="container mx-auto px-4 py-6">
                <a href="/" class="flex items-center gap-5 group hover:opacity-90 transition-opacity duration-150">
                    <img src="assets/marin-logo.png" alt="Marin Logo" class="h-14 w-14 object-contain">
                    <div class="flex flex-col justify-center">
                        <h1 class="text-3xl font-bold leading-tight">Marin Speedrun - Leaderboard</h1>
                        <p class="text-gray-300 text-sm mt-0.5">Community-driven model training leaderboard</p>
                    </div>
                </a>
            </div>
        </header>
        <main class="container mx-auto px-4 py-8">
            <div class="bg-white rounded-lg shadow p-8 mb-8">
                <div class="flex justify-between items-start mb-6">
                    <h2 class="text-3xl font-extrabold text-gray-900 font-display">What is Speedrun?</h2>
                    <a href="https://github.com/marin-community/marin/blob/main/docs/tutorials/submitting-speedrun.md" target="_blank" rel="noopener" class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-marin-blue hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-marin-blue transition-colors duration-150">
                        Get started with Speedrun
                    </a>
                </div>
                <p class="text-gray-600 leading-relaxed text-lg mb-8">
                    Speedrun is a community-driven initiative by the <a href="https://marin.community/" target="_blank" rel="noopener" class="text-marin-blue hover:text-blue-600 transition-colors duration-150">Marin project</a> to track and optimize the training efficiency of large language models. 
                    Have a new architecture or training procedure that you think is more efficient? Participate in the Marin speedrun competition (inspired by 
                    the <a href="https://github.com/KellerJordan/modded-nanogpt?tab=readme-ov-file#world-record-history" class="text-marin-blue hover:text-blue-600 transition-colors duration-150">nanogpt speedrun</a>), pick your compute budget, and create the fastest method to train a model to a 
                    certain quality! 
                </p>
                <p class="text-gray-600 leading-relaxed text-lg mb-8">
                    On this page, you can find leaderboards for different speedrun tracks, each targeting a specific loss threshold. You can click on any run to view the code that
                    generated it, or view the Weights & Biases link for the model! We also track the overall Pareto frontier of models, allowing us to track efficiency-performance tradeoffs across all tracks.
                </p>
                <p class="text-gray-600 leading-relaxed text-lg">
                    We invite you to join us in the search for more performant and efficient training methods!
                </p>
            </div>

            <!-- Track Selection -->
            <div class="bg-white rounded-lg shadow p-6 mb-8">
                <h3 class="text-xl font-semibold text-gray-900 mb-4">Speedrun Tracks</h3>
                <p class="text-gray-600 mb-4">Select a track to view runs targeting specific loss thresholds. Each track ranks runs by training efficiency (FLOPs) to reach the target loss.</p>
                <div id="track-buttons" class="flex flex-wrap gap-3">
                    <!-- Track buttons will be populated by JavaScript -->
                </div>
                <div id="track-description" class="mt-4 p-4 bg-gray-50 rounded-lg">
                    <p class="text-gray-700 text-sm">Select a track to see its description and leaderboard.</p>
                </div>
            </div>

            <div class="mb-8">
                <button id="clear-selection" class="px-4 py-2 rounded-md text-sm font-medium bg-gray-200 hover:bg-gray-300" style="display: none;">Clear Selection</button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Total Runs in Track</h3>
                    <div id="total-runs" class="text-2xl font-bold">-</div>
                </div>
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Best FLOPs in Track</h3>
                    <div id="best-flops" class="text-2xl font-bold">-</div>
                </div>
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Best C4-EN BPB</h3>
                    <div id="best-bpb" class="text-2xl font-bold">-</div>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow p-6 mb-8 relative h-96 flex flex-col">
                <h2 class="text-xl font-semibold text-gray-900 mb-4 flex-shrink-0">Overall Pareto Frontier: FLOPs vs. C4-EN BPB</h2>
                <div class="relative flex-grow">
                    <canvas id="pareto-chart" style="position: absolute; top: 0; left: 0; height: 100%; width: 100%;"></canvas>
                    <canvas id="overlay-canvas" style="position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none;"></canvas>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <div class="px-6 py-4 bg-gray-50 border-b border-gray-200">
                    <h3 id="leaderboard-title" class="text-lg font-semibold text-gray-900">Track Leaderboard</h3>
                    <p id="leaderboard-subtitle" class="text-sm text-gray-600 mt-1">Select a track to view its leaderboard</p>
                </div>
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Rank</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="run_name" data-default-direction="asc">Run Name <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Author</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="run_completion_timestamp" data-default-direction="desc">Date Added<span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="model_size" data-default-direction="asc">Model Size* <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="training_time" data-default-direction="asc">Training Time <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="training_hardware_flops" data-default-direction="asc">Total FLOPs* <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="eval_paloma_c4_en_bpb" data-default-direction="asc">C4-EN BPB <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">W&B Run</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="leaderboard-body"></tbody>
                </table>
                <div class="px-6 py-4 text-xs text-gray-500">
                    * Model size here refers to the total number of trainable parameters<br>
                    * Total FLOPs here refers to hardware FLOPs performed during training
                </div>
            </div>
        </main>
    </div>

    <script>
        let tracks = [];
        let currentTrack = null;
        let allEntries = [];
        let selectedRuns = new Set();
        let currentSort = { field: 'training_hardware_flops', direction: 'asc' };
        let paretoChart = null;
        let updateTimeout = null;

        async function fetchTracks() {
            try {
                const response = await fetch('./data/tracks.json', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching tracks data:", error);
                return [];
            }
        }

        async function fetchLeaderboard() {
            try {
                const response = await fetch('./data/runs.json', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                console.log('Raw response:', text);
                
                let data;
                try {
                    data = JSON.parse(text);
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    throw new Error('Failed to parse JSON response');
                }
                
                console.log('Parsed data:', data);
                
                if (!Array.isArray(data)) {
                    console.error('Data is not an array:', data);
                    throw new Error('Invalid data format');
                }
                
                return data.map(entry => {
                    const processed = {
                        run_name: entry.run_name || '',
                        author: entry.author || {},
                        run_completion_timestamp: entry.run_completion_timestamp || '',
                        model_size: parseFloat(entry.model_size) || 0,
                        training_hardware_flops: parseFloat(entry.training_hardware_flops) || 0,
                        training_time: parseFloat(entry.training_time) || 0,
                        eval_paloma_c4_en_bpb: parseFloat(entry.eval_paloma_c4_en_bpb) || null,
                        results_filepath: entry.results_filepath || '',
                        wandb_link: entry.wandb_link || null
                    };
                    return processed;
                });
            } catch (error) {
                console.error("Error fetching leaderboard data:", error);
                return [];
            }
        }

        function initializeTrackButtons() {
            const trackButtonsContainer = document.getElementById('track-buttons');
            trackButtonsContainer.innerHTML = '';

            tracks.forEach(track => {
                const button = document.createElement('button');
                button.className = 'track-btn px-4 py-2 rounded-md text-sm font-medium border transition-all duration-200';
                button.style.borderColor = track.color;
                button.style.color = track.color;
                button.textContent = track.name;
                button.dataset.trackId = track.id;
                
                button.addEventListener('click', () => selectTrack(track.id));
                trackButtonsContainer.appendChild(button);
            });

            // Select "All Runs" by default
            if (tracks.length > 0) {
                selectTrack('all');
            }
        }

        function selectTrack(trackId) {
            currentTrack = tracks.find(t => t.id === trackId);
            if (!currentTrack) return;

            // Update button states
            document.querySelectorAll('.track-btn').forEach(btn => {
                const isActive = btn.dataset.trackId === trackId;
                if (isActive) {
                    btn.style.backgroundColor = currentTrack.color;
                    btn.style.color = 'white';
                } else {
                    const track = tracks.find(t => t.id === btn.dataset.trackId);
                    btn.style.backgroundColor = 'transparent';
                    btn.style.color = track.color;
                }
            });

            // Update track description
            const descriptionEl = document.getElementById('track-description');
            const colorIndicatorHtml = currentTrack.id !== 'all' ? 
                `<span class="inline-block w-3 h-3 rounded-sm mr-2 align-middle" style="background-color: ${currentTrack.color}; border: 1px solid rgba(0,0,0,0.1);"></span>` : 
                '';
            descriptionEl.innerHTML = `
                <h4 class="font-semibold text-gray-900 mb-2">${colorIndicatorHtml}${currentTrack.name}</h4>
                <p class="text-gray-700 text-sm">${currentTrack.description}</p>
            `;

            // Update leaderboard
            updateLeaderboard();
        }

        function getTrackEntries(trackId) {
            if (trackId === 'all') {
                return allEntries;
            }
            
            const track = tracks.find(t => t.id === trackId);
            if (!track || track.target_bpb === null) {
                return allEntries;
            }

            return allEntries.filter(entry => 
                entry.eval_paloma_c4_en_bpb !== null && 
                entry.eval_paloma_c4_en_bpb <= track.target_bpb
            );
        }

        function formatModelSize(size) {
            if (!size) return "N/A";
            return size < 1e9 ? `${(size / 1e6).toFixed(1)}M` : `${(size / 1e9).toFixed(1)}B`;
        }

        function formatFlops(flops) {
            if (!flops) return "N/A";
            return flops.toExponential(2).replace('e+', 'E');
        }

        function formatMetric(value) {
            return value === null || isNaN(value) ? 'N/A' : value.toFixed(3);
        }

        function updateStats(entries) {
            // Update total runs count
            document.getElementById('total-runs').textContent = entries.length;

            if (entries.length === 0) {
                document.getElementById('best-flops').textContent = '-';
                document.getElementById('best-bpb').textContent = '-';
                return;
            }

            // Find best FLOPs (lowest) in track
            const validFlopsEntries = entries.filter(e => e.training_hardware_flops > 0);
            const bestFlops = validFlopsEntries.length > 0 ? 
                Math.min(...validFlopsEntries.map(e => e.training_hardware_flops)) : null;

            // Find best C4-EN BPB (lowest)
            const validBpbEntries = entries.filter(e => e.eval_paloma_c4_en_bpb !== null);
            const bestBpb = validBpbEntries.length > 0 ? 
                Math.min(...validBpbEntries.map(e => e.eval_paloma_c4_en_bpb)) : null;

            // Update stats display
            document.getElementById('best-flops').textContent = bestFlops ? formatFlops(bestFlops) : '-';
            document.getElementById('best-bpb').textContent = bestBpb !== null ? bestBpb.toFixed(3) : '-';
        }

        function computeParetoFrontier(entries) {
            const validEntries = entries.filter(e => 
                Number.isFinite(e.training_hardware_flops) && 
                e.training_hardware_flops > 0 && 
                Number.isFinite(e.eval_paloma_c4_en_bpb) && 
                e.eval_paloma_c4_en_bpb > 0
            );

            return validEntries.filter(entry => {
                const flops = entry.training_hardware_flops;
                const bpb = entry.eval_paloma_c4_en_bpb;

                return !validEntries.some(other => 
                    other.training_hardware_flops <= flops &&
                    other.eval_paloma_c4_en_bpb < bpb &&
                    (other.training_hardware_flops < flops || other.eval_paloma_c4_en_bpb < bpb)
                );
            });
        }

        function updateParetoChart(entries) {
            if (updateTimeout) clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                // Always use all entries for Pareto frontier, regardless of track
                const validEntries = allEntries.filter(
                    e => Number.isFinite(e.training_hardware_flops) && e.training_hardware_flops > 0 &&
                         Number.isFinite(e.eval_paloma_c4_en_bpb) && e.eval_paloma_c4_en_bpb > 0
                );
                
                if (!validEntries.length) {
                    if (paretoChart) {
                        paretoChart.destroy();
                        paretoChart = null;
                    }
                    const ctx = document.getElementById('pareto-chart').getContext('2d');
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    return;
                }

                const trackEntries = getTrackEntries(currentTrack?.id || 'all');
                const validTrackEntries = trackEntries.filter(
                    e => Number.isFinite(e.training_hardware_flops) && e.training_hardware_flops > 0 &&
                         Number.isFinite(e.eval_paloma_c4_en_bpb) && e.eval_paloma_c4_en_bpb > 0
                );

                const allChartData = validEntries.map(entry => ({
                    x: entry.training_hardware_flops / 1e18,
                    y: entry.eval_paloma_c4_en_bpb,
                    run_name: entry.run_name,
                    inTrack: validTrackEntries.includes(entry)
                }));

                const paretoEntries = computeParetoFrontier(validEntries);
                const paretoData = paretoEntries
                    .map(entry => ({
                        x: entry.training_hardware_flops / 1e18,
                        y: entry.eval_paloma_c4_en_bpb
                    }))
                    .sort((a, b) => a.x - b.x);

                // Calculate axis ranges
                const xValues = allChartData.map(d => d.x);
                const yValues = allChartData.map(d => d.y);
                const xAxisMin = Math.max(0, Math.min(...xValues) * 0.85);
                const xAxisMax = Math.max(...xValues) * 1.15;
                const yAxisMin = 1.0;
                const yAxisMax = 1.6;

                // Create datasets array
                const datasets = [
                    {
                        label: 'All Runs',
                        data: allChartData,
                        backgroundColor: allChartData.map(point => {
                            if (selectedRuns.has(point.run_name)) return 'rgba(255, 255, 0, 0.8)';
                            if (point.inTrack) return currentTrack?.color + '80' || 'rgba(54, 162, 235, 0.5)';
                            return 'rgba(156, 163, 175, 0.3)';
                        }),
                        borderColor: allChartData.map(point => {
                            if (selectedRuns.has(point.run_name)) return 'rgba(255, 255, 0, 1)';
                            if (point.inTrack) return currentTrack?.color || 'rgba(54, 162, 235, 1)';
                            return 'rgba(156, 163, 175, 0.6)';
                        }),
                        borderWidth: 1,
                        pointRadius: allChartData.map(point => point.inTrack ? 6 : 4),
                        pointHoverRadius: 8
                    },
                    {
                        label: 'Pareto Frontier',
                        data: paretoData,
                        backgroundColor: 'rgba(255, 99, 132, 0.5)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 2,
                        showLine: true,
                        fill: false,
                        tension: 0,
                        pointRadius: 0
                    }
                ];

                // Custom plugin to draw track background
                const trackBackgroundPlugin = {
                    id: 'trackBackground',
                    beforeDatasetsDraw: (chart) => {
                        if (currentTrack && currentTrack.target_bpb !== null) {
                            const ctx = chart.ctx;
                            const chartArea = chart.chartArea;
                            const yScale = chart.scales.y;
                            
                            // Convert target BPB to pixel position
                            const targetY = yScale.getPixelForValue(currentTrack.target_bpb);
                            
                            // Convert hex color to rgba
                            const hexToRgba = (hex, alpha) => {
                                const r = parseInt(hex.slice(1, 3), 16);
                                const g = parseInt(hex.slice(3, 5), 16);
                                const b = parseInt(hex.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            };
                            
                            // Draw filled rectangle from bottom to target line
                            ctx.save();
                            ctx.fillStyle = hexToRgba(currentTrack.color, 0.15);
                            ctx.fillRect(
                                chartArea.left,
                                targetY,
                                chartArea.right - chartArea.left,
                                chartArea.bottom - targetY
                            );
                            
                            // Draw target line
                            ctx.strokeStyle = hexToRgba(currentTrack.color, 0.6);
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(chartArea.left, targetY);
                            ctx.lineTo(chartArea.right, targetY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.restore();
                        }
                    }
                };

                if (paretoChart) {
                    paretoChart.destroy();
                }

                const ctx = document.getElementById('pareto-chart').getContext('2d');
                paretoChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    plugins: [trackBackgroundPlugin],
                    options: {
                        animation: false,
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                display: true
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        if (!point.run_name) {
                                            return `${point.x.toFixed(1)} EF, ${point.y.toFixed(3)} BPB`;
                                        }
                                        return `${point.run_name}: ${formatFlops(point.x * 1e18)} FLOPs, ${point.y.toFixed(3)} BPB`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Training FLOPs (ExaFLOPs)'
                                },
                                min: xAxisMin,
                                max: xAxisMax,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(1) + ' EF';
                                    },
                                    maxTicksLimit: 8
                                }
                            },
                            y: {
                                type: 'linear',
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'C4-EN BPB'
                                },
                                min: yAxisMin,
                                max: yAxisMax
                            }
                        }
                    }
                });
            }, 100);
        }

        function sortEntries(entries, field, direction) {
            return [...entries].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];

                if (field === 'run_completion_timestamp') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }

                if (aVal === null || aVal === undefined) return 1;
                if (bVal === null || bVal === undefined) return -1;

                return direction === 'asc' ? 
                    (aVal < bVal ? -1 : aVal > bVal ? 1 : 0) :
                    (aVal > bVal ? -1 : aVal < bVal ? 1 : 0);
            });
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'N/A';
            const formattedTimestamp = timestamp.replace(" UTC", "").replace(" ", "T") + "Z";
            const date = new Date(formattedTimestamp);
            if (isNaN(date.getTime())) return 'N/A';
            return date.toISOString().split('T')[0];
        }

        function formatAuthor(author) {
            if (!author) return 'N/A';
            const authorLink = author.url ? 
                `<a href="${author.url}" target="_blank" rel="noopener" class="text-marin-blue hover:text-blue-600 transition-colors duration-150">${author.name}</a>` : 
                author.name;
            return `${authorLink}<br><span class="text-gray-500 text-xs">${author.affiliation}</span>`;
        }

        function updateLeaderboard() {
            if (!currentTrack) return;

            const trackEntries = getTrackEntries(currentTrack.id);
            const sortedEntries = sortEntries(trackEntries, currentSort.field, currentSort.direction);
            
            updateStats(trackEntries);
            updateParetoChart(trackEntries);
            
            // Update leaderboard title
            document.getElementById('leaderboard-title').textContent = `${currentTrack.name} Leaderboard`;
            document.getElementById('leaderboard-subtitle').textContent = 
                currentTrack.id === 'all' ? 
                'All submitted runs sorted by selected criteria' :
                `Runs achieving ≤${currentTrack.target_bpb} C4-EN BPB, ranked by training efficiency (FLOPs)`;

            // Update leaderboard header with track color indicator
            const leaderboardHeader = document.querySelector('.bg-gray-50.border-b.border-gray-200');
            if (leaderboardHeader) {
                const titleElement = document.getElementById('leaderboard-title');
                
                // Remove any existing color indicator
                const existingIndicator = titleElement.querySelector('.track-color-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                // Add color indicator for non-"All Runs" tracks
                if (currentTrack.id !== 'all') {
                    const colorIndicator = document.createElement('span');
                    colorIndicator.className = 'track-color-indicator inline-block w-4 h-4 rounded-sm mr-3 align-middle';
                    colorIndicator.style.backgroundColor = currentTrack.color;
                    colorIndicator.style.border = '1px solid rgba(0,0,0,0.1)';
                    titleElement.insertBefore(colorIndicator, titleElement.firstChild);
                }
            }

            const tbody = document.getElementById('leaderboard-body');
            tbody.innerHTML = '';

            const baseGithubUrl = 'https://github.com/marin-community/marin/tree/main/';

            sortedEntries.forEach((entry, index) => {
                const row = document.createElement('tr');
                row.className = selectedRuns.has(entry.run_name) ? 'bg-blue-50' : (index % 2 === 0 ? 'bg-white' : 'bg-gray-50');

                const githubUrl = baseGithubUrl + entry.results_filepath;
                const cells = [
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 font-medium">${index + 1}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        <a href="${githubUrl}" target="_blank" rel="noopener" class="text-marin-blue hover:text-blue-600 transition-colors duration-150">${entry.run_name}</a>
                    </td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm">${formatAuthor(entry.author)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatDate(entry.run_completion_timestamp)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatModelSize(entry.model_size)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${entry.training_time.toFixed(1)}m</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatFlops(entry.training_hardware_flops)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${entry.eval_paloma_c4_en_bpb.toFixed(3)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        ${entry.wandb_link ? `<a href="${entry.wandb_link}" target="_blank" rel="noopener" class="text-marin-blue hover:text-blue-600 transition-colors duration-150">View Run</a>` : 'N/A'}
                    </td>`
                ];

                row.innerHTML = cells.join('');
                tbody.appendChild(row);
            });
        }

        document.getElementById('clear-selection').addEventListener('click', () => {
            selectedRuns.clear();
            document.getElementById('clear-selection').style.display = 'none';
            updateParetoChart();
            updateLeaderboard();
        });

        document.querySelectorAll('th[data-sort]').forEach(header => {
            header.addEventListener('click', () => {
                const field = header.dataset.sort;
                const defaultDirection = header.dataset.defaultDirection || 'asc';
                
                if (currentSort.field === field) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.field = field;
                    currentSort.direction = defaultDirection;
                }

                // Update all headers
                document.querySelectorAll('th[data-sort]').forEach(h => {
                    if (h.dataset.sort === currentSort.field) {
                        h.classList.add('active');
                        h.dataset.direction = currentSort.direction;
                    } else {
                        h.classList.remove('active');
                        delete h.dataset.direction;
                    }
                });

                updateLeaderboard();
            });
        });

        document.addEventListener('DOMContentLoaded', async () => {
            const mainCanvas = document.getElementById('pareto-chart');
            const overlayCanvas = document.getElementById('overlay-canvas');
            mainCanvas.parentElement.style.position = 'relative';
            
            const resizeOverlay = () => {
                overlayCanvas.width = mainCanvas.width;
                overlayCanvas.height = mainCanvas.height;
                overlayCanvas.style.left = `${mainCanvas.offsetLeft}px`;
                overlayCanvas.style.top = `${mainCanvas.offsetTop}px`;
            };
            resizeOverlay();
            window.addEventListener('resize', resizeOverlay);

            let startX, startY, endX, endY;
            let isDragging = false;

            mainCanvas.onmousedown = (e) => {
                const rect = mainCanvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                isDragging = true;
            };

            mainCanvas.onmousemove = (e) => {
                if (!isDragging) return;
                const rect = mainCanvas.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;
                const ctx = overlayCanvas.getContext('2d');
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
            };

            mainCanvas.onmouseup = (e) => {
                if (!isDragging) return;
                isDragging = false;
                const rect = mainCanvas.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;
                const ctx = overlayCanvas.getContext('2d');
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                const xAxis = paretoChart.scales['x'];
                const yAxis = paretoChart.scales['y'];
                const chartStartX = xAxis.getValueForPixel(startX);
                const chartEndX = xAxis.getValueForPixel(endX);
                const chartStartY = yAxis.getValueForPixel(startY);
                const chartEndY = yAxis.getValueForPixel(endY);

                const selectionMinX = Math.min(chartStartX, chartEndX);
                const selectionMaxX = Math.max(chartStartX, chartEndX);
                const selectionMinY = Math.min(chartStartY, chartEndY);
                const selectionMaxY = Math.max(chartStartY, chartEndY);

                selectedRuns.clear();
                const chartData = allEntries
                    .filter(e => Number.isFinite(e.training_hardware_flops) && e.training_hardware_flops > 0 && Number.isFinite(e.eval_paloma_c4_en_bpb) && e.eval_paloma_c4_en_bpb > 0)
                    .map(entry => ({
                        x: entry.training_hardware_flops / 1e18,
                        y: entry.eval_paloma_c4_en_bpb,
                        run_name: entry.run_name
                    }));
                chartData.forEach((point) => {
                    const x = point.x;
                    const y = point.y;
                    if (x >= selectionMinX && x <= selectionMaxX && y >= selectionMinY && y <= selectionMaxY) {
                        selectedRuns.add(point.run_name);
                    }
                });

                updateParetoChart();
                updateLeaderboard();
                document.getElementById('clear-selection').style.display = selectedRuns.size > 0 ? 'inline-block' : 'none';
            };

            // Load data and initialize
            tracks = await fetchTracks();
            allEntries = await fetchLeaderboard();
            
            if (typeof Chart === 'undefined') {
                await new Promise(resolve => {
                    const checkChart = setInterval(() => {
                        if (typeof Chart !== 'undefined') {
                            clearInterval(checkChart);
                            resolve();
                        }
                    }, 100);
                });
            }
            
            initializeTrackButtons();
        });
    </script>

    <style>
        .track-btn { transition: all 0.2s; }
        .track-btn:hover { background-color: #e5e7eb; }
        .track-btn.active { background-color: #1a73e8; color: white; }

        .sort-icon {
            display: inline-block;
            margin-left: 4px;
            font-size: 0.8em;
            opacity: 0.5;
            transition: transform 0.2s, opacity 0.2s;
        }

        th[data-sort].active .sort-icon {
            opacity: 1;
        }

        th[data-sort].active[data-direction='desc'] .sort-icon {
            transform: rotate(180deg);
        }
    </style>
</body>
</html>
