<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marin Speedrun - Leaderboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" defer></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'marin-blue': '#1a73e8',
                        'marin-dark': '#1e293b'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50">
    <div class="min-h-screen">
        <header class="bg-marin-dark text-white shadow-lg">
            <div class="container mx-auto px-4 py-6">
                <h1 class="text-3xl font-bold">Marin Speedrun - Leaderboard</h1>
                <p class="mt-2 text-gray-300">Community-driven model training leaderboard</p>
            </div>
        </header>
        <main class="container mx-auto px-4 py-8">
            <div class="mb-8">
                <button id="clear-selection" class="px-4 py-2 rounded-md text-sm font-medium bg-gray-200 hover:bg-gray-300" style="display: none;">Clear Selection</button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Total Number of Runs</h3>
                    <div id="total-runs" class="text-2xl font-bold">-</div>
                </div>
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Best C4-EN BPB</h3>
                    <div id="best-bpb" class="text-2xl font-bold">-</div>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow p-6 mb-8 relative h-96 flex flex-col">
                <h2 class="text-xl font-semibold text-gray-900 mb-4 flex-shrink-0">Pareto Frontier: FLOPs vs. C4-EN BPB</h2>
                <div class="relative flex-grow">
                    <canvas id="pareto-chart" style="position: absolute; top: 0; left: 0; height: 100%; width: 100%;"></canvas>
                    <canvas id="overlay-canvas" style="position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none;"></canvas>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Rank</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="run_name" data-default-direction="asc">Run Name <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Author</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="run_completion_timestamp" data-default-direction="desc">Timestamp (UTC) <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="model_size" data-default-direction="asc">Model Size* <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="training_time" data-default-direction="asc">Training Time <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="training_hardware_flops" data-default-direction="asc">Total FLOPs <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" data-sort="eval_paloma_c4_en_bpb" data-default-direction="asc">C4-EN BPB <span class="sort-icon">▼</span></th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">W&B Run</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="leaderboard-body"></tbody>
                </table>
                <div class="px-6 py-4 text-xs text-gray-500">
                    * Model size here refers to the total number of trainable parameters
                </div>
            </div>
        </main>
    </div>

    <script>
        async function fetchLeaderboard() {
            try {
                const response = await fetch('./data/runs.json');
                const data = await response.json();
                console.log('Loaded data:', data);

                return data.map(entry => ({
                    ...entry,
                    model_size: parseFloat(entry.model_size) || 0,
                    training_hardware_flops: parseFloat(entry.training_hardware_flops) || 0,
                    training_time: parseFloat(entry.training_time) || 0,
                    eval_paloma_c4_en_bpb: parseFloat(entry.eval_paloma_c4_en_bpb) || null
                }));
            } catch (error) {
                console.error("Error fetching leaderboard data:", error);
                return [];
            }
        }

        function formatModelSize(size) {
            if (!size) return "N/A";
            return size < 1e9 ? `${(size / 1e6).toFixed(1)}M` : `${(size / 1e9).toFixed(1)}B`;
        }

        function formatFlops(flops) {
            if (!flops) return "N/A";
            return flops.toExponential(2).replace('e+', 'E');
        }

        function formatMetric(value) {
            return value === null || isNaN(value) ? 'N/A' : value.toFixed(3);
        }

        function updateStats(entries) {
            // Update total runs count
            document.getElementById('total-runs').textContent = entries.length;

            if (entries.length === 0) {
                document.getElementById('best-bpb').textContent = '-';
                return;
            }

            // Find best C4-EN BPB
            const bestBpb = entries.reduce((min, entry) =>
                (entry.eval_paloma_c4_en_bpb && entry.eval_paloma_c4_en_bpb < min) ? entry.eval_paloma_c4_en_bpb : min,
                entries.find(e => e.eval_paloma_c4_en_bpb)?.eval_paloma_c4_en_bpb || Infinity);

            // Update stats display
            document.getElementById('best-bpb').textContent = bestBpb !== Infinity ? bestBpb.toFixed(3) : '-';
        }

        function computeParetoFrontier(entries) {
            const validEntries = entries.filter(e => 
                Number.isFinite(e.training_hardware_flops) && 
                e.training_hardware_flops > 0 && 
                Number.isFinite(e.eval_paloma_c4_en_bpb) && 
                e.eval_paloma_c4_en_bpb > 0
            );

            return validEntries.filter(entry => {
                const flops = entry.training_hardware_flops;
                const bpb = entry.eval_paloma_c4_en_bpb;

                return !validEntries.some(other => 
                    other.training_hardware_flops <= flops &&
                    other.eval_paloma_c4_en_bpb < bpb &&
                    (other.training_hardware_flops < flops || other.eval_paloma_c4_en_bpb < bpb)
                );
            });
        }

        let paretoChart = null;
        let selectedRuns = new Set();
        let allEntries = [];
        let currentSort = { field: 'eval_paloma_c4_en_bpb', direction: 'asc' };

        let updateTimeout = null;

        function updateParetoChart(entries) {
            if (updateTimeout) clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                const validEntries = entries.filter(
                    e => Number.isFinite(e.training_hardware_flops) && e.training_hardware_flops > 0 &&
                         Number.isFinite(e.eval_paloma_c4_en_bpb) && e.eval_paloma_c4_en_bpb > 0
                );
                if (!validEntries.length) {
                    if (paretoChart) {
                        paretoChart.destroy();
                        paretoChart = null;
                    }
                    const ctx = document.getElementById('pareto-chart').getContext('2d');
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    return;
                }

                const chartData = validEntries.map(entry => ({
                    x: entry.training_hardware_flops / 1e18, // Convert to ExaFLOPs
                    y: entry.eval_paloma_c4_en_bpb,
                    run_name: entry.run_name
                }));
                
                // Calculate axis ranges with padding
                const xValues = chartData.map(d => d.x);
                const yValues = chartData.map(d => d.y);
                
                // Calculate x-axis limits with 15% padding
                const xAxisMin = Math.max(0, Math.min(...xValues) * 0.85);
                const xAxisMax = Math.max(...xValues) * 1.15;
                
                // Fixed y-axis range
                const yAxisMin = 1.0;
                const yAxisMax = 1.6;

                const paretoEntries = computeParetoFrontier(validEntries);
                // Sort pareto points by x-value for proper line drawing
                const paretoData = paretoEntries
                    .map(entry => ({
                        x: entry.training_hardware_flops / 1e18,
                        y: entry.eval_paloma_c4_en_bpb
                    }))
                    .sort((a, b) => a.x - b.x);

                // Calculate data ranges for axis scaling
                const flopsValues = validEntries.map(e => e.training_hardware_flops / 1e18);
                const bpbValues = validEntries.map(e => e.eval_paloma_c4_en_bpb);
                const minFlops = Math.min(...flopsValues);
                const maxFlops = Math.max(...flopsValues);
                const minBPB = Math.min(...bpbValues);
                const maxBPB = Math.max(...bpbValues);

                // Calculate padding for better visualization
                const flopsRange = maxFlops - minFlops;
                const bpbRange = maxBPB - minBPB;
                const yPadding = bpbRange * 0.1;
                const xPadding = flopsRange * 0.1;

                const xMin = minFlops * 0.8;
                const xMax = maxFlops * 1.2;
                const yMin = Math.max(1.0, minBPB - yPadding);
                const yMax = maxBPB + yPadding;

                if (paretoChart) {
                    paretoChart.destroy();
                }

                const ctx = document.getElementById('pareto-chart').getContext('2d');
                paretoChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'All Runs',
                                data: chartData,
                                backgroundColor: chartData.map(point => 
                                    selectedRuns.has(point.run_name) ? 'rgba(255, 255, 0, 0.5)' : 'rgba(54, 162, 235, 0.5)'
                                ),
                                borderColor: chartData.map(point => 
                                    selectedRuns.has(point.run_name) ? 'rgba(255, 255, 0, 1)' : 'rgba(54, 162, 235, 1)'
                                ),
                                borderWidth: 1,
                                pointRadius: 6,
                                pointHoverRadius: 8
                            },
                            {
                                label: 'Pareto Frontier',
                                data: paretoData,
                                backgroundColor: 'rgba(255, 99, 132, 0.5)',
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 2,
                                showLine: true,
                                fill: false,
                                tension: 0
                            }
                        ]
                    },
                    options: {
                        animation: false,
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                display: true
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        if (!point.run_name) {
                                            return `${point.x.toFixed(1)} EF, ${point.y.toFixed(3)} BPB`;
                                        }
                                        return `${point.run_name}: ${formatFlops(point.x * 1e18)} FLOPs, ${point.y.toFixed(3)} BPB`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Training FLOPs (ExaFLOPs)'
                                },
                                min: xAxisMin,
                                max: xAxisMax,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(1) + ' EF';
                                    },
                                    maxTicksLimit: 8 // Limit number of ticks for better readability
                                }
                            },
                            y: {
                                type: 'linear',
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'C4-EN BPB'
                                },
                                min: yAxisMin,
                                max: yAxisMax
                            }
                        },
                        legend: { display: true }
                    }
                });
            }, 100);
        }

        function sortEntries(entries, field, direction) {
            return [...entries].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];

                if (field === 'run_completion_timestamp') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }

                if (aVal === null || aVal === undefined) return 1;
                if (bVal === null || bVal === undefined) return -1;

                return direction === 'asc' ? 
                    (aVal < bVal ? -1 : aVal > bVal ? 1 : 0) :
                    (aVal > bVal ? -1 : aVal < bVal ? 1 : 0);
            });
        }

        async function updateLeaderboard(entries) {
            allEntries = entries;
            const sortedEntries = sortEntries(entries, currentSort.field, currentSort.direction);
            updateStats(entries);
            updateParetoChart(entries);
            const tbody = document.getElementById('leaderboard-body');
            tbody.innerHTML = '';

            sortedEntries.forEach((entry, index) => {
                const row = document.createElement('tr');
                row.className = selectedRuns.has(entry.run_name) ? 'bg-blue-50' : (index % 2 === 0 ? 'bg-white' : 'bg-gray-50');

                const authorLink = entry.author.url ? 
                    `<a href="${entry.author.url}" target="_blank" class="text-blue-600 hover:text-blue-900">${entry.author.name}</a>` : 
                    entry.author.name;
                const authorInfo = `${authorLink}<br><span class="text-gray-500 text-xs">${entry.author.affiliation}</span>`;

                const cells = [
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${index + 1}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${entry.run_name}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm">${authorInfo}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${entry.run_completion_timestamp || 'N/A'}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatModelSize(entry.model_size)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatMetric(entry.training_time)}m</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatFlops(entry.training_hardware_flops)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatMetric(entry.eval_paloma_c4_en_bpb)}</td>`,
                    `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        ${entry.wandb_link ? `<a href="${entry.wandb_link}" target="_blank" class="text-blue-600 hover:text-blue-900">View Run</a>` : 'N/A'}
                    </td>`
                ];

                row.innerHTML = cells.join('');
                tbody.appendChild(row);
            });
        }

        document.getElementById('clear-selection').addEventListener('click', () => {
            selectedRuns.clear();
            document.getElementById('clear-selection').style.display = 'none';
            updateParetoChart(allEntries);
            updateLeaderboard(allEntries);
        });

        document.querySelectorAll('th[data-sort]').forEach(header => {
            // Set initial sort direction based on data attribute
            const defaultDirection = header.dataset.defaultDirection || 'asc';
            if (header.dataset.sort === 'eval_paloma_c4_en_bpb') {
                currentSort.field = 'eval_paloma_c4_en_bpb';
                currentSort.direction = 'asc';
                header.classList.add('active');
                header.dataset.direction = 'asc';
            }

            header.addEventListener('click', () => {
                const field = header.dataset.sort;
                if (currentSort.field === field) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.field = field;
                    currentSort.direction = defaultDirection;
                }

                // Update all headers
                document.querySelectorAll('th[data-sort]').forEach(h => {
                    if (h.dataset.sort === currentSort.field) {
                        h.classList.add('active');
                        h.dataset.direction = currentSort.direction;
                    } else {
                        h.classList.remove('active');
                        delete h.dataset.direction;
                    }
                });

                updateLeaderboard(allEntries);
            });
        });

        document.addEventListener('DOMContentLoaded', async () => {
            const mainCanvas = document.getElementById('pareto-chart');
            const overlayCanvas = document.getElementById('overlay-canvas');
            mainCanvas.parentElement.style.position = 'relative';
            const resizeOverlay = () => {
                overlayCanvas.width = mainCanvas.width;
                overlayCanvas.height = mainCanvas.height;
                overlayCanvas.style.left = `${mainCanvas.offsetLeft}px`;
                overlayCanvas.style.top = `${mainCanvas.offsetTop}px`;
            };
            resizeOverlay();
            window.addEventListener('resize', resizeOverlay);

            let startX, startY, endX, endY;
            let isDragging = false;

            mainCanvas.onmousedown = (e) => {
                const rect = mainCanvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                isDragging = true;
            };

            mainCanvas.onmousemove = (e) => {
                if (!isDragging) return;
                const rect = mainCanvas.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;
                const ctx = overlayCanvas.getContext('2d');
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
            };

            mainCanvas.onmouseup = (e) => {
                if (!isDragging) return;
                isDragging = false;
                const rect = mainCanvas.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;
                const ctx = overlayCanvas.getContext('2d');
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                const xAxis = paretoChart.scales['x'];
                const yAxis = paretoChart.scales['y'];
                const chartStartX = xAxis.getValueForPixel(startX);
                const chartEndX = xAxis.getValueForPixel(endX);
                const chartStartY = yAxis.getValueForPixel(startY);
                const chartEndY = yAxis.getValueForPixel(endY);

                const selectionMinX = Math.min(chartStartX, chartEndX);
                const selectionMaxX = Math.max(chartStartX, chartEndX);
                const selectionMinY = Math.min(chartStartY, chartEndY);
                const selectionMaxY = Math.max(chartStartY, chartEndY);

                selectedRuns.clear();
                const chartData = allEntries
                    .filter(e => Number.isFinite(e.training_hardware_flops) && e.training_hardware_flops > 0 && Number.isFinite(e.eval_paloma_c4_en_bpb) && e.eval_paloma_c4_en_bpb > 0)
                    .map(entry => ({
                        x: entry.training_hardware_flops / 1e18,
                        y: entry.eval_paloma_c4_en_bpb,
                        run_name: entry.run_name
                    }));
                chartData.forEach((point) => {
                    const x = point.x;
                    const y = point.y;
                    if (x >= selectionMinX && x <= selectionMaxX && y >= selectionMinY && y <= selectionMaxY) {
                        selectedRuns.add(point.run_name);
                    }
                });

                updateParetoChart(allEntries);
                updateLeaderboard(allEntries);
                document.getElementById('clear-selection').style.display = selectedRuns.size > 0 ? 'inline-block' : 'none';
            };

            const data = await fetchLeaderboard();
            if (typeof Chart === 'undefined') {
                await new Promise(resolve => {
                    const checkChart = setInterval(() => {
                        if (typeof Chart !== 'undefined') {
                            clearInterval(checkChart);
                            resolve();
                        }
                    }, 100);
                });
            }
            updateLeaderboard(data);
            updateParetoChart(data);
        });
    </script>

    <style>
        .track-btn { transition: all 0.2s; }
        .track-btn:hover { background-color: #e5e7eb; }
        .track-btn.active { background-color: #1a73e8; color: white; }

        .sort-icon {
            display: inline-block;
            margin-left: 4px;
            font-size: 0.8em;
            opacity: 0.5;
            transition: transform 0.2s, opacity 0.2s;
        }

        th[data-sort].active .sort-icon {
            opacity: 1;
        }

        th[data-sort].active[data-direction='desc'] .sort-icon {
            transform: rotate(180deg);
        }
    </style>
</body>
</html>
